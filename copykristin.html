<!DOCTYPE html>
	<head>
		<title>Copykristin</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
		
	</head>
	<body> 
		<div id="container"></div>
		<div id = "info">
			 Trackball Controls</div>
		
		<script src="three.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/stats.min.js"></script>
		<script src="js/FlyControls.js"></script>
		
		<script>
			
			//test if webGL is supported
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			
			var stats, camera, controls, scene, renderer;
			var container;
			//var startTime	= Date.now();
			
			init();
			animate();
		
		function init()
		{	
			//create camera
			camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 1000 );
			
			camera.position.set(0,0,100);
			
			//contructs an empty object and sets controls to it
			//var dummy = new THREE.Object3D();
		    //var controls = new THREE.FlyControls( dummy );
			
			//create controls
			controls = new THREE.TrackballControls( camera );
			//controls.target.se(0,0,0);
			
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;

			controls.noZoom = false;
			controls.noPan = false;

			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			
			
			/*
			//camera control properties
	     	controls.movementSpeed = 100;
            //controls.domElement = viewport;
            controls.rollSpeed = 0.5;
            controls.autoForward = false;
            controls.dragToLook = true;
			*/

			controls.keys = [ 65, 83, 68 ];

			controls.addEventListener( 'change', render );
			
			
			
			//---------world-------------
			
			//--------create scene----------
			scene = new THREE.Scene();
			//scene.fog = new THREE.FogExp2( 0x000000, 0.002 ); //sets start position in scene, defines exponential fog, ie. grows exponentially denser with the distance
			
			
			// -----------plane with/without texture---------------
			var w = 2, h = 2;

			
			// load texture file
			var planeTex = THREE.ImageUtils.loadTexture("textures/sara.jpg");
			// set repeating image all over the object
			planeTex.wrapS = planeTex.wrapT = THREE.RepeatWrapping;
			// set how small the image should be, how many times it should repeat
			planeTex.repeat.set( 4, 4 );
			// create a material with our texture to add on the object
			var planeMat = new THREE.MeshBasicMaterial( { map: planeTex } );
			// make sure the texture is applied to both sides
			planeMat.side = THREE.DoubleSide;


			// create first plane
			geometry = new THREE.PlaneGeometry( w, h );
			geometry2 = new THREE.PlaneGeometry( 20*w, 20*h );
			// (extra material for trying on computer since texture files won't work)
			var material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide}  );
			var material2 = new THREE.MeshBasicMaterial( {color: 0xff0000, side: THREE.DoubleSide} );

			// CHANGE MATERIAL TO PLANEMAT WHEN PUSHING TO GITHUB
			// create the actual object with correct geometry and material
			ground = new THREE.Mesh( geometry, material );
			extra = new THREE.Mesh ( geometry2, planeMat );

			//ground.position.set( 0, -10, 0 );
			//ground.rotation.x = Math.PI/2;
			//ground.scale.set( 10, 10, 10 );
			scene.add( ground );
			scene.add( extra );
			console.log("hej1")

			//ground.rotation.x += 3.14159/2;
			extra.rotation.x += 3.14159/2;

			extra.position.y = -10;

			// Kristins boxes
			/*var geometry = new THREE.BoxGeometry( 10, 10, 10 );
			var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			
			
			//var cube = new THREE.Mesh( geometry, material );
			
			for ( var i = 0; i < 500; i ++ ) {

				var mesh = new THREE.Mesh( geometry, material );
				mesh.position.x = ( Math.random() - 0.5 ) * 1000;
				mesh.position.y = ( Math.random() - 0.5 ) * 1000;
				mesh.position.z = ( Math.random() - 0.5 ) * 1000;
				mesh.updateMatrix();
				mesh.matrixAutoUpdate = false;
				scene.add( mesh );
				

			}*/

			// axis helper
			var axisHelper = new THREE.AxisHelper( 50 );
			scene.add( axisHelper );

			// skybox
			// view-source:http://stemkoski.github.io/Three.js/Skybox.html
			var imagePrefix = "images/dawnmountain-";
			var directions  = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
			var imageSuffix = ".png";
			var skyGeometry = new THREE.CubeGeometry( 500, 500, 500 );	
			
			// REMOVE FOR TESTING WITHOUT TEXTURES
			var materialArray = [];
			for (var i = 0; i < 6; i++)
				materialArray.push( new THREE.MeshBasicMaterial({
					map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
					side: THREE.BackSide
				}));
			var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
			// TO HERE

			//var himmelmaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.BackSide } );
			var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
			scene.add( skyBox );
			
			//-------------lights -------------
			/*light = new THREE.DirectionalLight( 0xffffff );
			light.position.set( 1, 1, 1 );
			scene.add( light );

			light = new THREE.DirectionalLight( 0x002288 );
			light.position.set( -1, -1, -1 );
			scene.add( light );
			
			light = new THREE.AmbientLight( 0x222222 );
			scene.add( light );
			*/

			
			//renderer
			renderer = new THREE.WebGLRenderer( { antialias: false } ); // antialias default is true so could skip the code
			//renderer.setClearColor( scene.fog.color ); //scene.fog.color sets far away objects to black, can also be a color
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			//document.body.appendChild( renderer.domElement );
			
			//create the conatiner element
			container = document.getElementById('container');
			container.appendChild( renderer.domElement );
			
			
			//init the stats
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild( stats.domElement );
			
			window.addEventListener( 'resize', onWindowResize, false );
		
			render();
			
		}
		
		function onWindowResize() 
		{
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

			controls.handleResize();

			render();
		}
		
		function animate() 
		{
			requestAnimationFrame( animate );
			controls.update();
		}
		
		function render() 
		{
			// update position to make texture of plane look like moving. 
			updatePosition(camera.position);
			renderer.render(scene, camera);
			stats.update();
		}

		// function for updating position and make texture look like you're moving
		// https://github.com/tapio/jetpursuit/blob/a78a4efd6ce5ea4f2cd41b74c23b1e803fa22095/js/world.js#L70-L73
		/* 
		I have an infinite ocean floor in my top-down game. I reposition it to the camera's xy-coordinates (keeping a distance with z). 
		I then modify the texture's offset property so that it appears the floor is moving even though it's glued to the camera.
		*/
		
		function updatePosition(position) 
		{
			// Infinite plane
			console.log("hej");
			ground.position.x = position.x;
			ground.position.z = position.z - 5;
			ground.position.y = position.y;
			// Note that the plane is created with (x,y)-coordinates, but we want to change (x,z) position 
			// since the plane is rotated pi/2. 
			//planeTex.offset.set(position.x / w * planeTex.repeat.x, position.z / h * planeTex.repeat.y);
		};
		


		</script>
	</body>
</html>

